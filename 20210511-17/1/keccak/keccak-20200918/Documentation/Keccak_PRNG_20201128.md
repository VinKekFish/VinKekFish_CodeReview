ФАЙЛ ДЛЯ АНАЛИЗА

Возможные ошибки: подача на вход данных, которые были взяты с выхода (зависят от выхода с этого шага)

1. Обратить особое внимание на то, что у объектов есть состояния "не инициализирован", "очищен"  и "уничтожен"

Состояния "не инициализирован" имеются.
Очищен - имеются (равны "не инициализирован")
Уничтожен - имеется

1.1. Желательно, чтобы эти состояния были в одной группе
Состояния не в одной группе. В целом объект пригоден для эксплуатации даже без инициализации. То есть его инициализация производится на старте в конструкторе.
Обнуление состояния происходит при выделении памяти с помощью оператора new.
Очищен и Уничтожен находятся в одной и той же группе

1.2.1. Из состояния "уничтожен" не должно быть выходов
CRFaVTKFxEqY - нет выходов

1.2.2. "Уничтожен" должно быть конечным состоянием (декларировано как конечное).
EfhOPm8967Zc

1.2.3. В состояния "Очищен" и "Уничтожен" можно попасть напрямую или опосредованно из любого другого состояния без проведения каких-либо операций, не соответствующих семантике очистки/уничтожения (пока код не проверяется, только описание состояний)

Так и есть. Из очищен в уничтожен. Из Полный в очищен.

1.2.4. По возможности, во время исполнения должна быть проверка того, что объект действительно подвергся очистке или уничтожению (то есть, что он не забыт)

Ошибка:
Такой проверки нет. Добавлена

1.4. В состоянии "не инициализирован" должно соответствовать семантике и быть сразу же после вызова конструктора. Если нужна дополнительная инициализация, то состояний "не инициализирован" может быть несколько.

Конструктор сразу же инициализирует объект.

2. Обратить особое внимание на то, указан ли допустимый порядок использования объекта (в зависимости от его состояний; допустимые переходы) и рекомендованный порядок состояний. Они должны быть указаны как в документации по состояниям, так и в понятной программисту-пользователю документации
Добавил пояснения

3. Переменные объекта.

3.0. Можно ли во время выполнения отличить, в каком состоянии находится объект?  (какие переменные на это указывают?) Если нельзя, то почему?

Копия для проверки по 3.0
# Состояния объекта
## Группа 1
    Очищен
		inputTo != null
    Полный
		inputTo != null
		На это состояние ничего не указывает. Однако, особо и не нужно, т.к. объект можно заполнять автоматически, вызывая функции более высокого уровня асбтракции
		Если есть сомнения между Полный и Очищен, необходимо вызвать Clear
    Уничтожен
		inputTo == null

## Группа 2
    Очищен
    Введён вектор инициализации

	Нет указаний. Предполагается, что и не надо.

## Группа 3
    Очищен
    Введён ключ
	
	Нет указаний. Предполагается, что и не надо. Теоретически, генератор может быть использован и в ином порядке, без введения ключа

## Группа 4
    Данные не готовы
		output.Count == 0
    Данные готовы
		output.Count > 0

	В целом, состояния можно определить.

3.1. Если есть переменные, которые указывают на состояние объекта, но не соответствуют формально описанным состояниям, то, возможно, стоит ввести новые группы состояний? (например, разделить группы)

Кажется, таких переменных нет

3.2. Если объект инициализируется по частям и очищается также, то выделены ли эти инициализации в отдельные группы состояний (со своими "частично очищен") и т.п.?
Выделено даже больше, чем надо, т.к. ключ сейчас вводится вместе с ОВИ.

4. Проверить, понятно ли описано, как создавать, использовать, утилизировать (очищать) объект для конченого программиста-пользователя

Кажется, достаточно рекомендованного порядка вызовов.


5. Все ли методы объекта указаны в документации по состояниям?
	Не все. Проверка проводится в сокращённом виде.

5.2. Хотя бы для одной группы должно быть верно следующее.
Метод всегда некорректно вызывать в одних состояниях группы и всегда корректно вызывать в других состояниях группы (то есть нет состояния, где его вызов может оказаться как корректным, так и не корректным)

Верно для всех методов для группы 1.
Верно для всех методов для группы 2.
Верно для всех методов для группы 3 при условии, что программист действует в согласии с алгоритмом, который реализует.
Для групп 4 и 5 вызовы могут плавать между состояниями.


6. Пригодные и непригодные состояния
1. Можно ли (во время исполнения программы) понять, что объект находится в состоянии "Утилизирован" ("уничтожен")? Если нет, то объект должен быть, после утилизации, недоступен.

Понять можно. intputTo = null

2. Можно ли во время выполнения программы понять, что объект находится в других непригодных состояниях? ("не инициализирован", "очищен", "частично инициализирован" и т.п.)
Нельзя. Кроме этого, в целом, там и нет непригодных состояний, кроме Уничтожен.

3. Можно ли во время исполнения программы понять, что объект находится в нужном для основного использования состоянии?

Объект всегда в таком состоянии находится, кроме мест, где уже уничтожен.

1. Верно инициализирован
Всегда верно инициализирован. Но вот понять, что ключ введён - нельзя.

2. Функции основного использования корректно вызывать в этом состоянии
Корректно всегда. Но нужно следовать алгоритму.

# Состояния объекта
## Группа 1
    Очищен
    Полный
    Уничтожен

## Группа 2
    Очищен
    Введён вектор инициализации

## Группа 3
    Очищен
    Введён ключ

## Группа 4
    Данные не готовы
    Данные готовы

## Группа 5
    Данные на вход не готовы
    Данные на вход готовы

# Рекомендуемые переходы между состояниями

Рекомендуемый порядок вызовов

    Вызов конструктора Keccak_PRNG_20201128
        1: Очищен
        2: Очищен
        3: Очищен
        4: Данные не готовы
        5: Данные на вход не готовы

    Вызов InputKeyAndStep
        1: Полный
        2: Введён вектор инициализации
        3: Введён ключ
        4: Данные не готовы (в целом, они есть в криптографическом состоянии, но они не изъяты оттуда)
        5: Данные на вход не готовы

    Вызов InputBytes с данными для ввода
        1: Полный
        2: Введён вектор инициализации
        3: Введён ключ
        4: Не изменяет
        5: Данные на вход готовы

    Вызовы calcStep или получение данных более высокими абстракциями столько раз, сколько потребуется
        1: Полный
        2: Введён вектор инициализации
        3: Введён ключ
        4: Данные готовы (в том случае, если calcStep вызывается с параметром SaveBytes = true, иначе - не изменяет)
        5: Изменяет в зависимости от состояния INPUT (см. inputReady или isInputReady)

    Переход к InputBytes, если это нужно

    Вызов Clear (если требуется повторное использование, начиная с InputKeyAndStep; Dispose вызывает Clear сам)
        1: Очищен
        2: Очищен
        3: Очищен
        4: Данные не готовы
        5: Данные на вход не готовы

    Вызов Dispose
        1: Очищен  // Ошибка: заменено на Уничтожен. В коде обнуление inputTo
        2: Очищен
        3: Очищен
        4: Данные не готовы
        5: Данные на вход не готовы

// TODO: Продолжить, ещё не сделал
# Допумстимые состояния

## Начальные состояния
    1: Очищен
    2: Очищен
    3: Очищен
    4: Данные не готовы
    5: Данные на вход не готовы

Объект должен использоваться однопоточно. Для обеспечения многопоточности нужно вручную использовать любой объект синхронизации (либо делать вызовы только в одном потоке)

## Конечные состояния
    1: Очищен				EfhOPm8967Zc // Ошибка: конечное состояние: не уничтожен
    2: Очищен
    3: Очищен
    4: Данные не готовы
    5: Данные на вход не готовы

# Допустимые переходы

Здесь движение от корня к листьям (это допустимые переходы)

## Группа 1
    Очищен
        Очищен
        Полный
        Уничтожен
    Полный
        Очищен
        Полный
    Уничтожен			CRFaVTKFxEqY
        _

## Группа 2
    Любые переходы

## Группа 3
    Любые переходы

## Группа 4
    Любые переходы

## Группа 5
    Любые переходы


# Переменные в состояниях
    (при переходах в какие состояния изменяется переменная)

## Группа 1
    Очищен
        inputTo очищен
        inputReady = false
        INPUT очищен
            INPUT.countOfBlocks == 0
        output очищен
            output.Count == 0
    Полный
    Уничтожен

## Группа 2
    Очищен
    Введён вектор инициализации

## Группа 3
    Очищен
    Введён ключ

## Группа 4
    Данные не готовы
        output.Count == 0
    Данные готовы
        output.Count > 0

## Группа 5
    inputReady = false
        Данные на вход не готовы
    inputReady = true
        Данные на вход готовы


## Переходы переменных осуществляются в следующих состояниях

См. выше "Переменные в состояниях"

# Переходы из состояний
(движение от листьев к корню; вызов в состоянии любого листа, выход из функции - состояние корня, передвижение по узлам происходит внутри функции)

## Конструктор Keccak_PRNG_20201128
Переводит объект в состояние
    1: Очищен
    2: Очищен
    3: Очищен
    4: Данные не готовы
    5: Данные на вход не готовы

см. "Рекомендуемые переходы между состояниями"
