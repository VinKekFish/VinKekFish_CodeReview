using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
 * Это отдельная библиотека, где разрешена оптимизация кода
 * Здесь никто ничего не обнуляет, только раундовые вычисления
 * */
namespace cryptoprime
{
    /// <summary>Статический класс, предоставляющий базовые функции и константы keccak. Пример использования см. в vinkekfish.Keccak_PRNG_20201128</summary>
    public static class keccak
    {
        public const int S_len  = 5;
        public const int S_len2 = S_len*S_len;  // Размер в ulong (== 25)

        public const int   r_512  = 576;
        public const int   r_512b = r_512 >> 3; // 72
        public const int   r_512s = r_512 >> 6; // 9

        public const int   b_size = 25*8;   // размер в байтах
        public const int   c_size =  5*8;   // размер в байтах

        public static readonly int[]   rNumbers = {1152, 1088, 832, 576}; // 224, 256, 384, 512 битов
        public static readonly ulong[] RC =
        {
            0x0000000000000001,
            0x0000000000008082,
            0x800000000000808A,
            0x8000000080008000,
            0x000000000000808B,
            0x0000000080000001,

            0x8000000080008081,
            0x8000000000008009,
            0x000000000000008A,
            0x0000000000000088,


            0x0000000080008009,
            0x000000008000000A,
            0x000000008000808B,
            0x800000000000008B,
            0x8000000000008089,

            0x8000000000008003,
            0x8000000000008002,
            0x8000000000000080,
            0x000000000000800A,
            0x800000008000000A,


            0x8000000080008081,
            0x8000000000008080,
            0x0000000080000001,
            0x8000000080008008
        };

        // Реализация раундов keccak и раундового преобразования
        // Раундовое преобразование
        /// <summary>a:[25*8], c:[5*8 == c_size], b:[25*8 == b_size]</summary>
        /// <param name="a">a:[25*8]</param>
        /// <param name="c">c:[5*8 == c_size]</param>
        /// <param name="b">b:[25*8 == b_size]</param>
        public static unsafe void roundB(ulong * a, ulong * c, ulong * b)
        {
            //шаг θ
            *(c + 0) = *(a +  0) ^ *(a +  1) ^ *(a +  2) ^ *(a +  3) ^ *(a +  4);
            *(c + 1) = *(a +  5) ^ *(a +  6) ^ *(a +  7) ^ *(a +  8) ^ *(a +  9);
            *(c + 2) = *(a + 10) ^ *(a + 11) ^ *(a + 12) ^ *(a + 13) ^ *(a + 14);
            *(c + 3) = *(a + 15) ^ *(a + 16) ^ *(a + 17) ^ *(a + 18) ^ *(a + 19);
            *(c + 4) = *(a + 20) ^ *(a + 21) ^ *(a + 22) ^ *(a + 23) ^ *(a + 24);

            var d = *(c + 4) ^ ((*(c + 1) << 1) | (*(c + 1) >> 63));
            *(a +  0) ^= d; // D[0];
            *(a +  1) ^= d; // D[0];
            *(a +  2) ^= d; // D[0];
            *(a +  3) ^= d; // D[0];
            *(a +  4) ^= d; // D[0];

            d = *(c + 0) ^ ((*(c + 2) << 1) | (*(c + 2) >> 63));
            *(a +  5) ^= d; // D[1];
            *(a +  6) ^= d; // D[1];
            *(a +  7) ^= d; // D[1];
            *(a +  8) ^= d; // D[1];
            *(a +  9) ^= d; // D[1];

            d = *(c + 1) ^ ((*(c + 3) << 1) | (*(c + 3) >> 63));
            *(a + 10) ^= d; // D[2];
            *(a + 11) ^= d; // D[2];
            *(a + 12) ^= d; // D[2];
            *(a + 13) ^= d; // D[2];
            *(a + 14) ^= d; // D[2];

            d = *(c + 2) ^ ((*(c + 4) << 1) | (*(c + 4) >> 63));
            *(a + 15) ^= d; // D[3];
            *(a + 16) ^= d; // D[3];
            *(a + 17) ^= d; // D[3];
            *(a + 18) ^= d; // D[3];
            *(a + 19) ^= d; // D[3];

            d = *(c + 3) ^ ((*(c + 0) << 1) | (*(c + 0) >> 63));
            *(a + 20) ^= d; // D[4];
            *(a + 21) ^= d; // D[4];
            *(a + 22) ^= d; // D[4];
            *(a + 23) ^= d; // D[4];
            *(a + 24) ^= d; // D[4];
            

            //шаги ρ и π

            *(b +  0) =  *(a +  0);                             // rot(A[0, 0], r[0, 0]);
            *(b +  8) = (*(a +  1) << 36) | (*(a +  1) >> 28);  // rot(A[0, 1], r[0, 1]);
            *(b + 11) = (*(a +  2) <<  3) | (*(a +  2) >> 61);  // rot(A[0, 2], r[0, 2]);
            *(b + 19) = (*(a +  3) << 41) | (*(a +  3) >> 23);  // rot(A[0, 3], r[0, 3]);
            *(b + 22) = (*(a +  4) << 18) | (*(a +  4) >> 46);  // rot(A[0, 4], r[0, 4]);

            *(b +  2) = (*(a +  5) <<  1) | (*(a +  5) >> 63);  // rot(A[1, 0], r[1, 0]);
            *(b +  5) = (*(a +  6) << 44) | (*(a +  6) >> 20);  // rot(A[1, 1], r[1, 1]);
            *(b + 13) = (*(a +  7) << 10) | (*(a +  7) >> 54);  // rot(A[1, 2], r[1, 2]);
            *(b + 16) = (*(a +  8) << 45) | (*(a +  8) >> 19);  // rot(A[1, 3], r[1, 3]);
            *(b + 24) = (*(a +  9) <<  2) | (*(a +  9) >> 62);  // rot(A[1, 4], r[1, 4]);

            *(b +  4) = (*(a + 10) << 62) | (*(a + 10) >>  2);  // rot(A[2, 0], r[2, 0]);
            *(b +  7) = (*(a + 11) <<  6) | (*(a + 11) >> 58);  // rot(A[2, 1], r[2, 1]);
            *(b + 10) = (*(a + 12) << 43) | (*(a + 12) >> 21);  // rot(A[2, 2], r[2, 2]);
            *(b + 18) = (*(a + 13) << 15) | (*(a + 13) >> 49);  // rot(A[2, 3], r[2, 3]);
            *(b + 21) = (*(a + 14) << 61) | (*(a + 14) >>  3);  // rot(A[2, 4], r[2, 4]);

            *(b +  1) = (*(a + 15) << 28) | (*(a + 15) >> 36);  // rot(A[3, 0], r[3, 0]);
            *(b +  9) = (*(a + 16) << 55) | (*(a + 16) >>  9);  // rot(A[3, 1], r[3, 1]);
            *(b + 12) = (*(a + 17) << 25) | (*(a + 17) >> 39);  // rot(A[3, 2], r[3, 2]);
            *(b + 15) = (*(a + 18) << 21) | (*(a + 18) >> 43);  // rot(A[3, 3], r[3, 3]);
            *(b + 23) = (*(a + 19) << 56) | (*(a + 19) >>  8);  // rot(A[3, 4], r[3, 4]);

            *(b +  3) = (*(a + 20) << 27) | (*(a + 20) >> 37);  // rot(A[4, 0], r[4, 0]);
            *(b +  6) = (*(a + 21) << 20) | (*(a + 21) >> 44);  // rot(A[4, 1], r[4, 1]);
            *(b + 14) = (*(a + 22) << 39) | (*(a + 22) >> 25);  // rot(A[4, 2], r[4, 2]);
            *(b + 17) = (*(a + 23) <<  8) | (*(a + 23) >> 56);  // rot(A[4, 3], r[4, 3]);
            *(b + 20) = (*(a + 24) << 14) | (*(a + 24) >> 50);  // rot(A[4, 4], r[4, 4]);

            //шаг χ

            *(a +  0) = *(b +  0) ^ ((~*(b +  5)) & *(b + 10));
            *(a +  1) = *(b +  1) ^ ((~*(b +  6)) & *(b + 11));
            *(a +  2) = *(b +  2) ^ ((~*(b +  7)) & *(b + 12));
            *(a +  3) = *(b +  3) ^ ((~*(b +  8)) & *(b + 13));
            *(a +  4) = *(b +  4) ^ ((~*(b +  9)) & *(b + 14));

            *(a +  5) = *(b +  5) ^ ((~*(b + 10)) & *(b + 15));
            *(a +  6) = *(b +  6) ^ ((~*(b + 11)) & *(b + 16));
            *(a +  7) = *(b +  7) ^ ((~*(b + 12)) & *(b + 17));
            *(a +  8) = *(b +  8) ^ ((~*(b + 13)) & *(b + 18));
            *(a +  9) = *(b +  9) ^ ((~*(b + 14)) & *(b + 19));

            *(a + 10) = *(b + 10) ^ ((~*(b + 15)) & *(b + 20));
            *(a + 11) = *(b + 11) ^ ((~*(b + 16)) & *(b + 21));
            *(a + 12) = *(b + 12) ^ ((~*(b + 17)) & *(b + 22));
            *(a + 13) = *(b + 13) ^ ((~*(b + 18)) & *(b + 23));
            *(a + 14) = *(b + 14) ^ ((~*(b + 19)) & *(b + 24));

            *(a + 15) = *(b + 15) ^ ((~*(b + 20)) & *(b +  0));
            *(a + 16) = *(b + 16) ^ ((~*(b + 21)) & *(b +  1));
            *(a + 17) = *(b + 17) ^ ((~*(b + 22)) & *(b +  2));
            *(a + 18) = *(b + 18) ^ ((~*(b + 23)) & *(b +  3));
            *(a + 19) = *(b + 19) ^ ((~*(b + 24)) & *(b +  4));

            *(a + 20) = *(b + 20) ^ ((~*(b +  0)) & *(b +  5));
            *(a + 21) = *(b + 21) ^ ((~*(b +  1)) & *(b +  6));
            *(a + 22) = *(b + 22) ^ ((~*(b +  2)) & *(b +  7));
            *(a + 23) = *(b + 23) ^ ((~*(b +  3)) & *(b +  8));
            *(a + 24) = *(b + 24) ^ ((~*(b +  4)) & *(b +  9));

            //шаг ι - выполняется во внешнйе подпрограмме
        }

        // Полный keccak
        /// <summary>Все раунды keccak. a == S, c= C, b = B</summary>
        /// <param name="a">Зафиксированное внутреннее состояние S: 25 * ulong (константа b_size)</param>
        /// <param name="c">Массив C (значения не важны):   5 * ulong (константа c_size)</param>
        /// <param name="b">Матрица B (значения не важны): 25 * ulong (константа b_size)</param>
        public static unsafe void Keccackf(ulong * a, ulong * c, ulong * b)
        {
            roundB(a, c, b);
            //шаг ι
            *a ^= 0x0000000000000001;

            roundB(a, c, b); *a ^= 0x0000000000008082;
            roundB(a, c, b); *a ^= 0x800000000000808A;
            roundB(a, c, b); *a ^= 0x8000000080008000;

            roundB(a, c, b); *a ^= 0x000000000000808B;
            roundB(a, c, b); *a ^= 0x0000000080000001;
            roundB(a, c, b); *a ^= 0x8000000080008081;
            roundB(a, c, b); *a ^= 0x8000000000008009;

            roundB(a, c, b); *a ^= 0x000000000000008A;
            roundB(a, c, b); *a ^= 0x0000000000000088;
            roundB(a, c, b); *a ^= 0x0000000080008009;
            roundB(a, c, b); *a ^= 0x000000008000000A;

            roundB(a, c, b); *a ^= 0x000000008000808B;
            roundB(a, c, b); *a ^= 0x800000000000008B;
            roundB(a, c, b); *a ^= 0x8000000000008089;
            roundB(a, c, b); *a ^= 0x8000000000008003;

            roundB(a, c, b); *a ^= 0x8000000000008002;
            roundB(a, c, b); *a ^= 0x8000000000000080;
            roundB(a, c, b); *a ^= 0x000000000000800A;
            roundB(a, c, b); *a ^= 0x800000008000000A;

            roundB(a, c, b); *a ^= 0x8000000080008081;
            roundB(a, c, b); *a ^= 0x8000000000008080;
            roundB(a, c, b); *a ^= 0x0000000080000001;
            roundB(a, c, b); *a ^= 0x8000000080008008;
        }

        // keccak с неполными раундами
        /// <summary>Неполнораундовый keccack</summary>
        /// <param name="a">25*8</param>
        /// <param name="c">5*8</param>
        /// <param name="b">25*8</param>
        /// <param name="start">Начальный шаг, от нуля</param>
        /// <param name="count">Количество шагов (всего шагов столько, сколько констант в RC)</param>
        public static unsafe void Keccack_i(ulong * a, ulong * c, ulong * b, int start, int count)
        {
            var end = start + count;
            for (int i = start; i < end; i++)   // всегда завершится верно
            {
                roundB(a, c, b); *a ^= RC[i];       // При переполнении, в крайнем случае, будет runtime-ошибка
            }
        }

        /// <summary>Ввод данных в состояние keccak. Предназначен только для версии 512 битов</summary>
        /// <param name="message">:[len] :[0,72] Указатель на очередную порцию данных длины не менее len</param>
        /// <param name="len">Количество байтов для записи (не более 72-х; константа r_512b)</param>
        /// <param name="S">:[25*8] Внутреннее состояние S</param>
        /// <param name="setPaddings">Если <see langword="true"/> - ввести padding в массив (при вычислении хеша делать на последнем блоке <= 71 байта)</param>
        // НИЖЕ КОПИЯ Keccak_InputOverwrite_512 (небольшая разница, но методы, в целом, идентичны)
        public static unsafe void Keccak_Input_512(byte * message, byte len, byte * S, bool setPaddings = false)
        {
            if (len > r_512b || len < 0)
            {
                throw new ArgumentOutOfRangeException("len > r_512b || len < 0");
            }

            // В конце 72-хбайтового блока нужно поставить оконечный padding
            // Матрица S размера 5x5*ulong
            // Мы пропустили 8 ulong (64-ре байта), то есть 8-5=3 сейчас индекс у нас 3, но т.к. матрица транспонирована, то нам нужен не индекс [1, 3], а индекс [3, 1]
            // В индекс [3, 1] мы должны в старший байт записать 0x80. Значит, 3*5*8 + 1*8 + 7 = 135
            byte * es    = S + 135; // es находится в рамках S, т.к.  byte * S, то есть "+" идёт побайтово. S имеет размер 25*8=200 байтов. 135 < 200
            byte * lastS = S;           // Если len = 0, то записываем в первый байт

            // lastS = S - в пределах диапазона, индекс 0

            // Общий смысл инициализации
            // Массив информации в размере 72 байта записывается в начало состояния из 25-ти 8-мибайтовых слов; однако матрица S при этом имеет транспонированные индексы
            int i1 = 0, i2 = 0, i3 = 0, ss = S_len << 3; // ss = 5 << 3 = 40 = 5 * 8 - это размер c_size - размер строки, заменено на c_size
            for (int i = 0; i < len; i++)   // i:[0, len]
                                            // len:[0, 72]
                                            // i:[0, [0, 72]]
            {
                // В цикл может не быть захода вообще. Паддинги, в таком случае, всё равно устанавливаются. См. метку 91KlzGAv4lfQ ниже (setPaddings)

                // В цикле нет ни одного изменения значения i, значит i пробегает
                // диапазон i:[0, [0, 72]]

                // i3 инкрементируется на единицу. Если i3 >= 8, то i3 обнуляется. Проверка выполняется после инкремента. Значит 
                // i3:[0, 7]

                // i2 икрементируется на единицу. После инкремента стоит проверка i2 >= S_len.Если так, то i2 обнуляется.
                // Значит i2:[0, S_len-1], S_len = 5
                // i2:[0, 4]

                // i1 инкрементируется на единицу под условием. Никаких ограничений нет, кроме runtime проверки if (i1 >= S_len).
                // То есть i1:[0, 4]. Посмотрим, так ли это
                // Инкремент проходит каждый раз, когда i2 обнуляется.
                // i2 обнуляется, когда её значение доходит до 5.
                // Таким образом, i2 проходит начало цикла в значениях: {0, 1, 2, 3, 4}. На i2 = 4 приращение даёт 5, после чего следует обнуление
                // Однако, приразения i2 осуществляются, только если i3 достигло 8-ми.
                // То есть i3 обнуляется каждый 8-ой проход цикла.
                // То есть i2 обнуляется каждый 5-ый проход обнуления i3.
                // То есть i2 обнуляется каждый 5*8 проход цикла.
                // Всего проходов не более len = 72, 72/40=1,8
                // То есть i2 обнуляется не более 1-ого раза, а значит, i1 испытывает не более 1-ого приращения. Значит
                // i1:[0, 1]

                // S всегда указывает на начало криптографического состояния, т.к. нигде не изменяется
                // byte * S - в байтах, значит, указатель приращается в байтах
                // Значит, индекс в массиве S у нас идёт через вычисление (i1 << 3) + i2*ss + i3
                // i1:[0, 1], ss = c_size = 40, i2:[0, 4], i3:[0, 7]
                // Операция сложения монотонна
                // Минимум функции (i1 << 3) + i2*ss + i3
                // (0 << 3) + 0*ss + 0 = 0
                // Максимум
                // (1 << 3) + 4*ss + 7 = 1*8 + 4*40 + 7 = 175
                // Ддина S равна b_size = 200, 175 < 200. Выхода за пределы диапазона нет
                // Максимум в рантайме, если вышесказанное неверно:
                // (4 << 3) + 4*ss + 7 = 4*8 + 4*40 + 7 = 199 < 200. Выхода за пределы диапазона нет

                lastS = S + (i1 << 3) + i2*ss + i3;   // i2*ss - не ошибка, т.к. индексы в матрице транспонированны
                *lastS ^= *message;         // xor в пределах диапазона
                message++;                      // message приращается только здесь. Приращается не более, чем len раз
                // Это значит, что message указывает в диапазоне индексов [0, len]. Последнее приращение указывает за границу массива
                // То есть после message++ других операций с этим указателем быть не должно ни в цикле, ни после него.
                // Так и есть

                // Выполняем приращения индексов в матрице
                i3++;
                if (i3 >= 8)
                {
                    i3 = 0;
                    i2++;   // Приращаем следующий индекс
                }
                if (i2 >= S_len)
                {
                    i2 = S_len; // Ошибка: обнаружена лишняя операция
                    i2 = 0;
                    i1++;
                }

                // Это даже на последней итерации не должно выполняться // i1:[0, 1]
                if (i1 >= S_len)
                {
                    throw new Exception();
                }

                // Это вычисление нужно для того, чтобы потом записать верно padding
                // Для len = 71 значение lastS должно совпасть с es
                // Данное выражение уже проверено выше на предмет переполнения
                lastS = S + (i1 << 3) + i2*ss + i3;

                // len = 71
                // i1 = 1
                // i2 = (71 - 1*40)/8 = 3,875 = 3
                // i3 = (71 - 1*40 - 3*8) = 7
                // (1 << 3) + 3*ss + 7 = 1*8 + 3*40 + 7 = 135
                // es, действительно, сдвинуто именно на 135 байтов от начала S
            }
            // :91KlzGAv4lfQ
            if (setPaddings)
            {
                if (len >= r_512b)
                    throw new ArgumentOutOfRangeException("len >= r_512b (must be < 72)");

                // Здесь уже всё доказано, однако, можно вставить доп. проверки, если очень хочется
                 *lastS ^= 0x01;
                 *es    ^= 0x80;
            }
        }

        
        /// <summary>
        /// Эта конструкция разработана по мотивам keccak Overwrite, но немного от неё отличается
        /// Никаких paddings не делаем! Осторожно, учитывайте это при вводе. Вводить надо ровно 64 байта (можно вводить и меньше, но криптостойкость под вопросом, т.к. ввод не однозначный)
        /// Здесь нет ни paddings, ни framebit, ничего подобного.
        /// </summary>
        /// <param name="message">64 байта или менее для ввода с помощью перезаписи</param>
        /// <param name="len">длина массива message, 64 или менее</param>
        /// <param name="S">Внутреннее состояние keccak</param>

        // Этот метод должен быть почти полной копией Keccak_Input_512, за исключением небольших изменений
        public static unsafe void Keccak_InputOverwrite64_512(byte * message, byte len, byte * S)
        {
            const byte RB = 64;
            if (len > RB || len < 0)
            {
                throw new ArgumentOutOfRangeException("len > 64 || len < 0");
            }

            byte * lastS  = S;           // Если len = 0, то записываем в первый байт

            // Общий смысл инициализации
            // Массив информации в размере 64 байта записывается в начало состояния из 25-ти 8-мибайтовых слов; однако матрица S при этом имеет транспонированные индексы
            // Байты, которые не введены, просто считаются нулями (то есть состояние всё равно перезаписывается)
            // Никаких paddings не делаем!
            int i1 = 0, i2 = 0, i3 = 0, ss = S_len << 3;
            int i = 0;          // Цикл абсолютно аналогичен вышестоящему и уже проверенному. При этом len:[0, 64], то есть значения будут даже меньше
            for (; i < RB; i++) // +1 чтобы сделать padding
            {
                lastS = S + (i1 << 3) + i2*ss + i3;
                if (i < len)
                    *lastS = *message;   // ЗДЕСЬ ИЗМЕНЕНИЕ! Это впитывание не для Sponge, а для Overwrite
                else
                    *lastS = 0;

                message++;

                // Выполняем приращения индексов в матрице
                i3++;
                if (i3 >= 8)
                {
                    i3 = 0;
                    i2++;   // Приращаем следующий индекс
                }
                if (i2 >= S_len)
                {
                    i2 = S_len;
                    i2 = 0;
                    i1++;
                }

                // Это даже на последней итерации не должно выполняться
                if (i1 >= S_len)
                {
                    throw new Exception();
                }
            }
        }

        /// <summary>Вывод данных из состояния keccak. Предназначен только для версии 512 битов</summary>
        /// <param name="output">Указатель на массив, готовый принять данные :[0, 72]</param>
        /// <param name="len">Количество байтов для записи (не более 72-х; константа r_512b). Обычно используется 64 - это стойкость данного криптографического преобразования</param>
        /// <param name="S">Внутреннее состояние S :[200]</param>
        // При вызове надо проверить, что output всегда нужной длины
        public static unsafe void Keccak_Output_512(byte * output, byte len, byte * S)
        {
            if (len > r_512b || len < 0)
            {
                throw new ArgumentOutOfRangeException("len > r_512b || len < 0");
            }

            // Матрица S - это матрица 5x5 по 8 байтов. Мы проходим по первому столбцу, и собираем оттуда данные
            // Потом - по второму столбцу, и собираем оттуда данные
            for (int i = 0; i < 40;  i += 8)  // 40 = 8*5
            for (int j = 0; j < 200; j += 40) // 200 = 40*5
            for (int k = 0; k < 8; k++)
            {
                if (len == 0)
                    goto End;
                
                // output:[0, len]
                // Приращается только один раз и ровно столько раз, сколько уменьшается len
                // Допустим, len = 1. Тогда будет запись output[0], output++, len--, то есть len = 0, а значит, следующий шаг цикла начнётся с выхода из цикла
                // После цикла output указывает на неразрешённый для записи участок памяти. output не дожен использоваться
                // Так и есть.
                // Таким образом, чем больше len, тем больше будет приращений output. Вроде бы, всё хорошо.

                // i:[0, 40-8], j:[0, 200-40], k:[0, 7]
                // i:[0, 32], j:[0, 160], k:[0, 7]
                // Максимум i + j + k = 32 + 160 + 7 = 199 < 200 - нет выхода за пределы массива S
                *output = *(S + i + j + k);

                output++;
                len--;
            }

            End: ;
        }
    }
}
